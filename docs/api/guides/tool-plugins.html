<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Building Plugins - jaato docs</title>
  <link rel="stylesheet" href="../assets/css/style.css">
</head>
<body>
  <!-- Header -->
  <header class="header">
    <a href="../index.html" class="header-logo">
      jaato <span>docs</span>
    </a>
    <nav class="header-nav">
      <a href="../getting-started/quickstart.html">Quickstart</a>
      <a href="../api-reference/index.html">API Reference</a>
      <a href="https://github.com/apanoia/jaato" target="_blank">GitHub</a>
      <div class="header-search">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
        <input type="text" placeholder="Search docs... (press /)">
      </div>
    </nav>
  </header>

  <!-- Layout -->
  <div class="layout">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar-section">
        <div class="sidebar-title">Getting Started</div>
        <ul class="sidebar-nav">
          <li><a href="../getting-started/quickstart.html">Quickstart</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Core Concepts</div>
        <ul class="sidebar-nav">
          <li><a href="../core-concepts/client.html">Client</a></li>
          <li><a href="../core-concepts/plugins.html">Plugins</a></li>
          <li><a href="../core-concepts/tools.html">Tools</a></li>
          <li><a href="../core-concepts/providers.html">Providers</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Guides</div>
        <ul class="sidebar-nav">
          <li><a href="tool-plugins.html" class="active">Building Plugins</a></li>
          <li><a href="mcp-integration.html">MCP Integration</a></li>
          <li><a href="permissions.html">Permissions</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">API Reference</div>
        <ul class="sidebar-nav">
          <li><a href="../api-reference/index.html">Overview</a></li>
          <li><a href="../api-reference/jaato-client.html">JaatoClient</a></li>
          <li><a href="../api-reference/plugin-registry.html">PluginRegistry</a></li>
          <li><a href="../api-reference/types.html">Types</a></li>
        </ul>
      </div>
    </aside>

    <!-- Main content -->
    <main class="main">
      <!-- Introduction -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h1>Building Plugins</h1>
          <p class="lead">
            Learn how to create custom tool plugins that extend jaato's capabilities.
            Plugins can expose tools to the model, provide user commands, or both.
          </p>

          <h2 id="overview">Overview</h2>
          <p>
            A plugin is a Python module that follows a simple protocol. At minimum,
            it provides:
          </p>
          <ul>
            <li><strong>Tool schemas</strong> — What tools are available</li>
            <li><strong>Executors</strong> — Functions that run the tools</li>
          </ul>
          <p>
            Optionally, plugins can also provide user commands, auto-approved tools,
            and prompt enrichment.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Plugin structure</div>
          <div class="code-block">
            <pre><code class="language-python"># shared/plugins/my_plugin/
#   __init__.py
#   plugin.py

# __init__.py
from .plugin import create_plugin

# plugin.py
class MyPlugin:
    def initialize(self, config):
        """Called once with configuration."""
        pass

    def get_tool_schemas(self):
        """Return list of ToolSchema."""
        return [...]

    def get_executors(self):
        """Return dict of name -> callable."""
        return {...}</code></pre>
          </div>
        </div>
      </section>

      <!-- Step 1: Create Plugin Class -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="create-class">Step 1: Create the Plugin Class</h2>
          <p>
            Start by creating a new directory under <code>shared/plugins/</code>
            with your plugin name. Then create the main plugin class.
          </p>

          <h3>Required Methods</h3>
          <table>
            <thead>
              <tr>
                <th>Method</th>
                <th>Returns</th>
                <th>Purpose</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>initialize(config)</code></td>
                <td><code>None</code></td>
                <td>Setup with configuration dict</td>
              </tr>
              <tr>
                <td><code>get_tool_schemas()</code></td>
                <td><code>List[ToolSchema]</code></td>
                <td>Declare available tools</td>
              </tr>
              <tr>
                <td><code>get_executors()</code></td>
                <td><code>Dict[str, Callable]</code></td>
                <td>Map tool names to functions</td>
              </tr>
            </tbody>
          </table>

          <h3>Optional Methods</h3>
          <table>
            <thead>
              <tr>
                <th>Method</th>
                <th>Returns</th>
                <th>Purpose</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>get_user_commands()</code></td>
                <td><code>List[UserCommand]</code></td>
                <td>Commands users can invoke directly (see Step 4)</td>
              </tr>
              <tr>
                <td><code>get_auto_approved_tools()</code></td>
                <td><code>List[str]</code></td>
                <td>Tool names that skip permission checks</td>
              </tr>
              <tr>
                <td><code>get_prompt_enrichment()</code></td>
                <td><code>str</code></td>
                <td>Text added to system prompt to guide the model</td>
              </tr>
              <tr>
                <td><code>supports_interactivity()</code></td>
                <td><code>bool</code></td>
                <td>Declares if plugin requires user interaction (see Step 4.5)</td>
              </tr>
              <tr>
                <td><code>get_supported_channels()</code></td>
                <td><code>List[str]</code></td>
                <td>Compatible channels: console, queue, webhook, file (see Step 4.5)</td>
              </tr>
              <tr>
                <td><code>set_channel()</code></td>
                <td><code>None</code></td>
                <td>Configure the interaction channel for the plugin (see Step 4.5)</td>
              </tr>
            </tbody>
          </table>

          <div class="callout callout-info">
            <div class="callout-title">When to Use Optional Methods</div>
            <ul style="margin: 8px 0 0 0; padding-left: 20px;">
              <li><strong>get_user_commands()</strong> — Your plugin provides commands users type directly (e.g., <code>/search</code>)</li>
              <li><strong>get_auto_approved_tools()</strong> — Your tools are safe to run without asking permission (read-only operations)</li>
              <li><strong>get_prompt_enrichment()</strong> — The model needs context about when/how to use your tools</li>
              <li><strong>Interactivity methods</strong> — Your plugin asks questions or shows progress to users</li>
            </ul>
          </div>
        </div>
        <div class="panel-code">
          <div class="code-label">Basic plugin class</div>
          <div class="code-block">
            <pre><code class="language-python">from shared.plugins.model_provider.types import ToolSchema

class WeatherPlugin:
    """Plugin that provides weather information."""

    def __init__(self):
        self.api_key = None
        self.default_units = "celsius"

    def initialize(self, config: dict):
        """
        Called by registry with configuration.

        Args:
            config: Dict with plugin settings
        """
        self.api_key = config.get("api_key")
        self.default_units = config.get(
            "units",
            "celsius"
        )

    def get_tool_schemas(self):
        """Declare the tools this plugin provides."""
        return [
            ToolSchema(
                name="get_weather",
                description="Get current weather for a city",
                parameters={
                    "type": "object",
                    "properties": {
                        "city": {
                            "type": "string",
                            "description": "City name"
                        },
                        "units": {
                            "type": "string",
                            "enum": ["celsius", "fahrenheit"],
                            "description": "Temperature units"
                        }
                    },
                    "required": ["city"]
                }
            )
        ]

    def get_executors(self):
        """Map tool names to executor functions."""
        return {
            "get_weather": self._get_weather
        }

    def _get_weather(self, city: str, units: str = None):
        """Execute the get_weather tool."""
        units = units or self.default_units
        # Implementation here...
        return f"Weather in {city}: 22°C, Sunny"</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Optional method examples</div>
          <div class="code-block">
            <pre><code class="language-python"># Auto-approved tools (safe, read-only operations)
def get_auto_approved_tools(self):
    """List tools that don't need permission prompts."""
    return [
        "get_weather",  # Read-only, safe
        "list_cities"   # Just lists data
    ]
    # Don't auto-approve: delete, modify, execute


# Prompt enrichment (guide the model)
def get_prompt_enrichment(self):
    """Add context to help model use tools correctly."""
    return """
You have access to weather tools. Use get_weather
to check current conditions for any city worldwide.
Temperature units can be celsius or fahrenheit.
Always specify the city name clearly.
"""</code></pre>
          </div>
        </div>
      </section>

      <!-- Step 2: Define Tool Schemas -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="tool-schemas">Step 2: Define Tool Schemas</h2>
          <p>
            Tool schemas tell the model what tools are available and how to use them.
            Use clear descriptions—the model relies on these to decide when to use your tool.
          </p>

          <h3>ToolSchema Fields</h3>
          <table>
            <thead>
              <tr>
                <th>Field</th>
                <th>Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>name</code></td>
                <td><code>str</code></td>
                <td>Unique tool identifier</td>
              </tr>
              <tr>
                <td><code>description</code></td>
                <td><code>str</code></td>
                <td>What the tool does (model reads this)</td>
              </tr>
              <tr>
                <td><code>parameters</code></td>
                <td><code>dict</code></td>
                <td>JSON Schema for parameters</td>
              </tr>
            </tbody>
          </table>

          <div class="callout callout-info">
            <div class="callout-title">Write Good Descriptions</div>
            The model uses descriptions to decide when to call your tool.
            Be specific: instead of "searches files", say "searches file contents
            using regex patterns, returns matching lines with context".
          </div>

          <h3>Parameter Type Mapping</h3>
          <p>
            JSON Schema types in <code>parameters</code> map to Python types in your
            executor function signatures. Use this table as a reference:
          </p>
          <table>
            <thead>
              <tr>
                <th>JSON Schema Type</th>
                <th>Python Type</th>
                <th>Example Value</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>"string"</code></td>
                <td><code>str</code></td>
                <td><code>"hello"</code></td>
              </tr>
              <tr>
                <td><code>"number"</code></td>
                <td><code>float</code></td>
                <td><code>3.14</code></td>
              </tr>
              <tr>
                <td><code>"integer"</code></td>
                <td><code>int</code></td>
                <td><code>42</code></td>
              </tr>
              <tr>
                <td><code>"boolean"</code></td>
                <td><code>bool</code></td>
                <td><code>True</code></td>
              </tr>
              <tr>
                <td><code>"array"</code></td>
                <td><code>list</code></td>
                <td><code>[1, 2, 3]</code></td>
              </tr>
              <tr>
                <td><code>"object"</code></td>
                <td><code>dict</code></td>
                <td><code>{"key": "value"}</code></td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="panel-code">
          <div class="code-label">Schema examples</div>
          <div class="code-block">
            <pre><code class="language-python">from shared.plugins.model_provider.types import ToolSchema

# Simple tool with required parameter
search_schema = ToolSchema(
    name="search_files",
    description="""
    Search file contents using regex patterns.
    Returns matching lines with file path and
    line numbers. Use for finding code, config
    values, or text patterns.
    """,
    parameters={
        "type": "object",
        "properties": {
            "pattern": {
                "type": "string",
                "description": "Regex pattern to search"
            },
            "path": {
                "type": "string",
                "description": "Directory to search in"
            },
            "file_types": {
                "type": "array",
                "items": {"type": "string"},
                "description": "File extensions: ['.py', '.js']"
            }
        },
        "required": ["pattern"]
    }
)

# Tool with enum parameter
format_schema = ToolSchema(
    name="format_code",
    description="Format source code file",
    parameters={
        "type": "object",
        "properties": {
            "file_path": {
                "type": "string",
                "description": "Path to file"
            },
            "style": {
                "type": "string",
                "enum": ["black", "autopep8", "yapf"],
                "description": "Formatter to use"
            }
        },
        "required": ["file_path", "style"]
    }
)

# Tool with no parameters
list_schema = ToolSchema(
    name="list_todos",
    description="List all pending todo items",
    parameters={
        "type": "object",
        "properties": {}
    }
)</code></pre>
          </div>
        </div>
      </section>

      <!-- Step 3: Implement Executors -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="executors">Step 3: Implement Executors</h2>
          <p>
            Executors are the functions that actually run when the model calls your tool.
            They receive the parameters from the model and return a result string.
          </p>

          <h3>Executor Requirements</h3>
          <ul>
            <li>Function signature must match schema parameters</li>
            <li>Return a string (the result shown to the model)</li>
            <li>Handle errors gracefully—return error messages, don't raise</li>
            <li>Keep execution time reasonable</li>
          </ul>

          <h3>Return Values</h3>
          <p>
            The return value is sent back to the model as the tool result.
            Format it clearly—the model needs to understand and use this output.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Executor implementation</div>
          <div class="code-block">
            <pre><code class="language-python">import subprocess
import json

class MyPlugin:
    def get_executors(self):
        return {
            "search_files": self._search_files,
            "run_tests": self._run_tests,
        }

    def _search_files(
        self,
        pattern: str,
        path: str = ".",
        file_types: list = None
    ) -> str:
        """
        Search for pattern in files.

        Returns formatted results or error message.
        """
        try:
            cmd = ["grep", "-rn", pattern, path]

            if file_types:
                for ft in file_types:
                    cmd.extend(["--include", f"*{ft}"])

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0:
                return result.stdout or "No matches found"
            elif result.returncode == 1:
                return "No matches found"
            else:
                return f"Error: {result.stderr}"

        except subprocess.TimeoutExpired:
            return "Error: Search timed out"
        except Exception as e:
            return f"Error: {str(e)}"

    def _run_tests(
        self,
        test_path: str = None,
        verbose: bool = False
    ) -> str:
        """Run pytest and return results."""
        try:
            cmd = ["pytest"]
            if test_path:
                cmd.append(test_path)
            if verbose:
                cmd.append("-v")

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300
            )

            # Return both stdout and stderr
            output = result.stdout
            if result.stderr:
                output += f"\n\nStderr:\n{result.stderr}"

            return output

        except Exception as e:
            return f"Error running tests: {e}"</code></pre>
          </div>
        </div>
      </section>

      <!-- Step 4: Add User Commands -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="user-commands">Step 4: Add User Commands (Optional)</h2>
          <p>
            User commands let users invoke functionality directly without going
            through the model. Useful for quick actions or when you want
            deterministic behavior.
          </p>

          <h3>UserCommand Fields</h3>
          <table>
            <thead>
              <tr>
                <th>Field</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>name</code></td>
                <td>Command name (e.g., "search")</td>
              </tr>
              <tr>
                <td><code>description</code></td>
                <td>Help text for the command</td>
              </tr>
              <tr>
                <td><code>share_with_model</code></td>
                <td>Add output to conversation history?</td>
              </tr>
            </tbody>
          </table>

          <div class="callout callout-warning">
            <div class="callout-title">share_with_model</div>
            <p>
              <code>share_with_model=True</code>: Output goes to history, model sees it
            </p>
            <p>
              <code>share_with_model=False</code>: Output only shown to user
            </p>
            <p>
              This does NOT expose the command as a model tool.
            </p>
          </div>
        </div>
        <div class="panel-code">
          <div class="code-label">Adding user commands</div>
          <div class="code-block">
            <pre><code class="language-python">from shared.plugins.base import UserCommand

class MyPlugin:
    def get_user_commands(self):
        """Define commands users can invoke directly."""
        return [
            UserCommand(
                "search",
                "Search files: /search <pattern>",
                share_with_model=True
            ),
            UserCommand(
                "clear_cache",
                "Clear plugin cache",
                share_with_model=False
            ),
        ]

    def execute_user_command(
        self,
        command_name: str,
        args: dict
    ) -> tuple:
        """
        Execute a user command.

        Returns:
            (result, share_with_model)
        """
        if command_name == "search":
            pattern = args.get("query", "")
            result = self._search_files(pattern)
            return (result, True)

        elif command_name == "clear_cache":
            self._cache = {}
            return ("Cache cleared", False)

        return (f"Unknown command: {command_name}", False)</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">User invokes command</div>
          <div class="code-block">
            <pre><code class="language-python"># User types: /search TODO
#
# With share_with_model=True:
#   1. Plugin runs search
#   2. Results shown to user
#   3. Results added to conversation history
#   4. Model can reference results in next turn

# With share_with_model=False:
#   1. Plugin runs command
#   2. Results shown to user only
#   3. Model never sees the output</code></pre>
          </div>
        </div>
      </section>

      <!-- Step 4.5: Interactive Plugins -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="interactive-plugins">Step 4.5: Interactive Plugins (Optional)</h2>
          <p>
            Plugins that require user interaction (permissions, questions, progress reporting)
            should implement the interactivity protocol. This allows clients to verify
            compatibility and configure the appropriate interaction channel.
          </p>

          <h3>Channel Types</h3>
          <ul>
            <li><strong>console</strong> — Standard terminal stdin/stdout</li>
            <li><strong>queue</strong> — Callback-based I/O for TUI/rich clients</li>
            <li><strong>webhook</strong> — HTTP-based remote interaction</li>
            <li><strong>file</strong> — Filesystem-based communication</li>
          </ul>

          <h3>When to Use</h3>
          <p>
            Implement this protocol if your plugin:
          </p>
          <ul>
            <li>Prompts users for approval (like permission checks)</li>
            <li>Asks questions requiring user input</li>
            <li>Presents selection dialogs</li>
            <li>Reports progress with real-time updates</li>
          </ul>

          <p>
            Clients can use <code>supports_interactivity()</code> to check if a plugin
            requires user interaction, then verify the plugin supports their channel type
            via <code>get_supported_channels()</code> before loading.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Interactive plugin example</div>
          <div class="code-block">
            <pre><code class="language-python">class ProgressPlugin:
    """Plugin with interactive progress reporting."""

    def __init__(self):
        self._reporter = None

    # ... tool schemas and executors ...

    def supports_interactivity(self) -> bool:
        """Declare interactive features."""
        return True

    def get_supported_channels(self) -> List[str]:
        """List compatible channels."""
        return ["console", "queue", "webhook", "file"]

    def set_channel(
        self,
        channel_type: str,
        channel_config: Optional[Dict[str, Any]] = None
    ) -> None:
        """Configure the interaction channel."""
        if channel_type not in self.get_supported_channels():
            raise ValueError(f"Unsupported channel: {channel_type}")

        # Create appropriate reporter/channel
        if channel_type == "console":
            config = channel_config or {}
            # For queue-based clients, config includes:
            #   - output_callback: (source, text, mode) -> None
            self._reporter = ConsoleReporter(config)
        elif channel_type == "webhook":
            self._reporter = WebhookReporter(channel_config)
        # ... handle other channel types ...</code></pre>
          </div>

          <div class="code-label">Client compatibility check</div>
          <div class="code-block">
            <pre><code class="language-python"># Rich TUI client checking compatibility
def load_plugin(plugin: ToolPlugin) -> bool:
    if plugin.supports_interactivity():
        supported = plugin.get_supported_channels()

        if "queue" not in supported:
            print(f"Warning: {plugin.name} doesn't support queue channel")
            print(f"Supported: {supported}")
            return False

        # Configure for TUI with callbacks
        plugin.set_channel("queue", {
            "output_callback": self.output_callback,
            "input_queue": self.input_queue,
            "prompt_callback": self.prompt_callback
        })

    return True</code></pre>
          </div>
        </div>
      </section>

      <!-- Step 5: Register Plugin -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="register">Step 5: Register the Plugin</h2>
          <p>
            Finally, create the factory function and register your plugin
            so it can be discovered by the registry.
          </p>

          <h3>Factory Function</h3>
          <p>
            The <code>create_plugin()</code> function is called by the registry
            during discovery. It should return a new instance of your plugin.
          </p>

          <h3>Plugin Metadata</h3>
          <p>
            Add a <code>PLUGIN_INFO</code> dict to help with discovery and
            provide metadata about your plugin.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">__init__.py</div>
          <div class="code-block">
            <pre><code class="language-python"># shared/plugins/weather/__init__.py

from .plugin import WeatherPlugin

PLUGIN_INFO = {
    "name": "weather",
    "description": "Weather information tools",
    "version": "1.0.0",
    "author": "Your Name",
}

def create_plugin():
    """Factory function called by registry."""
    return WeatherPlugin()</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Using your plugin</div>
          <div class="code-block">
            <pre><code class="language-python">from shared import JaatoClient, PluginRegistry

# Create client and registry
client = JaatoClient()
client.connect(project, location, model)

registry = PluginRegistry(model_name=model)
registry.discover()

# Expose your plugin
registry.expose_tool("weather")

# Configure client with tools
client.configure_tools(registry)

# Now the model can use get_weather
response = client.send_message(
    "What's the weather in Tokyo?",
    on_output=lambda s, t, m: print(t, end="")
)</code></pre>
          </div>
        </div>
      </section>

      <!-- Step 6: Package with pyproject.toml -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="packaging">Step 6: Package with pyproject.toml</h2>
          <p>
            For distributable plugins, create a proper Python package with
            <code>pyproject.toml</code>. This enables installation via pip
            and proper dependency management.
          </p>

          <h3>Project Structure</h3>
          <pre style="background: var(--color-bg-secondary); padding: 12px; border-radius: 4px; font-size: 13px; color: var(--color-text);">
my-jaato-plugin/
├── pyproject.toml
├── README.md
├── src/
│   └── my_plugin/
│       ├── __init__.py
│       └── plugin.py
└── tests/
    └── test_plugin.py</pre>

          <h3>Key Fields</h3>
          <table>
            <thead>
              <tr>
                <th>Field</th>
                <th>Purpose</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>name</code></td>
                <td>Package name for pip install</td>
              </tr>
              <tr>
                <td><code>dependencies</code></td>
                <td>Required packages</td>
              </tr>
              <tr>
                <td><code>entry-points</code></td>
                <td>Plugin discovery hook</td>
              </tr>
            </tbody>
          </table>

          <div class="callout callout-info">
            <div class="callout-title">Entry Points</div>
            The <code>[project.entry-points]</code> section allows jaato to
            discover your plugin automatically when installed.
          </div>
        </div>
        <div class="panel-code">
          <div class="code-label">pyproject.toml</div>
          <div class="code-block">
            <pre><code class="language-python">[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "jaato-plugin-weather"
version = "1.0.0"
description = "Weather tools for jaato"
readme = "README.md"
requires-python = ">=3.10"
license = "MIT"
authors = [
    { name = "Your Name", email = "you@example.com" }
]

dependencies = [
    "requests>=2.28.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "pytest-asyncio",
]

# Entry point for plugin discovery
[project.entry-points."jaato.plugins"]
weather = "my_plugin:create_plugin"

[tool.hatch.build.targets.wheel]
packages = ["src/my_plugin"]</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Install and use</div>
          <div class="code-block">
            <pre><code class="language-python"># Install in development mode
pip install -e .

# Or install from PyPI (after publishing)
pip install jaato-plugin-weather

# Plugin is now discoverable
from shared import PluginRegistry

registry = PluginRegistry(model_name=model)
registry.discover()  # Finds your plugin!
registry.expose_tool("weather")</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">src/my_plugin/__init__.py</div>
          <div class="code-block">
            <pre><code class="language-python">from .plugin import WeatherPlugin

PLUGIN_INFO = {
    "name": "weather",
    "description": "Weather information tools",
    "version": "1.0.0",
}

def create_plugin():
    """Entry point for jaato plugin discovery."""
    return WeatherPlugin()</code></pre>
          </div>
        </div>
      </section>

      <!-- Step 7: Testing Your Plugin -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="testing">Step 7: Testing Your Plugin</h2>
          <p>
            Before integrating your plugin into the main system, test it
            standalone to verify correctness. This ensures your plugin
            works independently of the jaato client.
          </p>

          <h3>Testing Approach</h3>
          <ol>
            <li>Import your plugin using the factory function</li>
            <li>Initialize with test configuration</li>
            <li>Verify tool schemas are correctly defined</li>
            <li>Test each executor with valid inputs</li>
            <li>Test error handling with invalid inputs</li>
            <li>Verify output format and content</li>
          </ol>

          <h3>What to Test</h3>
          <ul>
            <li><strong>Schema Validation</strong> — Correct names, descriptions, parameters</li>
            <li><strong>Executor Mapping</strong> — All schemas have matching executors</li>
            <li><strong>Happy Path</strong> — Valid inputs produce expected outputs</li>
            <li><strong>Error Cases</strong> — Invalid inputs return error messages (not exceptions)</li>
            <li><strong>Configuration</strong> — initialize() properly sets config values</li>
            <li><strong>Edge Cases</strong> — Boundary conditions, empty inputs, special characters</li>
          </ul>

          <div class="callout callout-info">
            <div class="callout-title">Environment Setup</div>
            If your test needs dependencies, create a virtual environment first:
            <pre style="margin-top: 8px; background: var(--color-bg-secondary); padding: 8px; border-radius: 4px; font-size: 13px;">python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt</pre>
          </div>
        </div>
        <div class="panel-code">
          <div class="code-label">test_my_plugin.py</div>
          <div class="code-block">
            <pre><code class="language-python">#!/usr/bin/env python3
"""Test script for my plugin."""

import json


def test_plugin():
    """Test plugin implementation."""
    print("Testing My Plugin")
    print("=" * 60)

    # Test 1: Import and create
    print("\n[1] Importing plugin...")
    from shared.plugins.my_plugin import create_plugin, PLUGIN_INFO
    plugin = create_plugin()
    print(f"✓ Created: {PLUGIN_INFO['name']}")

    # Test 2: Initialize
    print("\n[2] Initializing...")
    plugin.initialize({"precision": 3})
    print("✓ Initialized with config")

    # Test 3: Get schemas
    print("\n[3] Getting tool schemas...")
    schemas = plugin.get_tool_schemas()
    print(f"✓ Found {len(schemas)} tools")
    for schema in schemas:
        print(f"  - {schema.name}")

    # Test 4: Get executors
    print("\n[4] Getting executors...")
    executors = plugin.get_executors()
    assert len(executors) == len(schemas), \
        "Executor count must match schema count"
    print(f"✓ All {len(executors)} executors present")

    # Test 5: Test valid input
    print("\n[5] Testing valid input...")
    result = plugin._my_tool("valid_input")
    print(f"✓ Result: {result[:50]}...")

    # Verify it's valid JSON (if using JSON format)
    try:
        data = json.loads(result)
        assert "result" in data
        print("✓ Valid JSON structure")
    except json.JSONDecodeError:
        print("  (Plain text result)")

    # Test 6: Test error handling
    print("\n[6] Testing error handling...")
    error_result = plugin._my_tool("")  # Invalid
    assert "Error" in error_result or "error" in error_result.lower()
    print(f"✓ Error handled: {error_result[:50]}...")

    # Test 7: Test edge cases
    print("\n[7] Testing edge cases...")
    edge_result = plugin._my_tool("   ")  # Whitespace
    assert isinstance(edge_result, str)
    print("✓ Edge case handled")

    print("\n" + "=" * 60)
    print("All tests passed! ✓")
    return True


if __name__ == "__main__":
    import sys
    success = test_plugin()
    sys.exit(0 if success else 1)</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Run tests</div>
          <div class="code-block">
            <pre><code class="language-bash"># With virtual environment
.venv/bin/python test_my_plugin.py

# Or use pytest for more features
.venv/bin/pytest test_my_plugin.py -v</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Example output</div>
          <div class="code-block">
            <pre><code class="language-bash">Testing My Plugin
============================================================

[1] Importing plugin...
✓ Created: my_plugin

[2] Initializing...
✓ Initialized with config

[3] Getting tool schemas...
✓ Found 2 tools
  - my_tool
  - another_tool

[4] Getting executors...
✓ All 2 executors present

[5] Testing valid input...
✓ Result: {"result": "success", "data": "output"}...
✓ Valid JSON structure

[6] Testing error handling...
✓ Error handled: Error: parameter required...

[7] Testing edge cases...
✓ Edge case handled

============================================================
All tests passed! ✓</code></pre>
          </div>
        </div>
      </section>

      <!-- Best Practices -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="best-practices">Best Practices</h2>

          <h3>Error Handling</h3>
          <p>
            Never let exceptions propagate from executors. Always catch and return
            meaningful error messages.
          </p>

          <h3>Timeouts</h3>
          <p>
            Long-running operations should have timeouts. The model is waiting
            for your result.
          </p>

          <h3>Clear Output</h3>
          <p>
            Format output so the model can parse and use it. JSON works well
            for structured data.
          </p>

          <h3>Minimal Dependencies</h3>
          <p>
            Keep external dependencies minimal. If you need them, document
            them clearly.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Error handling pattern</div>
          <div class="code-block">
            <pre><code class="language-python">def _my_executor(self, param: str) -> str:
    """Always return a string, never raise."""
    try:
        # Validate input
        if not param:
            return "Error: parameter required"

        # Do the work with timeout
        result = self._do_work(param, timeout=30)

        # Format output clearly
        return json.dumps({
            "status": "success",
            "data": result
        }, indent=2)

    except TimeoutError:
        return "Error: operation timed out"
    except ValueError as e:
        return f"Error: invalid input - {e}"
    except Exception as e:
        # Log for debugging, return generic message
        logging.error(f"Executor failed: {e}")
        return f"Error: {str(e)}"</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Structured output</div>
          <div class="code-block">
            <pre><code class="language-python"># Good: structured, parseable
def _search(self, query: str) -> str:
    results = self._do_search(query)
    return json.dumps({
        "query": query,
        "count": len(results),
        "results": [
            {"file": r.file, "line": r.line, "text": r.text}
            for r in results[:10]
        ]
    }, indent=2)

# Also good: clear text format
def _search(self, query: str) -> str:
    results = self._do_search(query)
    lines = [f"Found {len(results)} matches for '{query}':"]
    for r in results[:10]:
        lines.append(f"  {r.file}:{r.line}: {r.text}")
    return "\n".join(lines)</code></pre>
          </div>
        </div>
      </section>

      <!-- Next Steps -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="next-steps">Next Steps</h2>
          <p>
            Now that you know how to build plugins, explore these related topics:
          </p>
          <ul>
            <li><a href="../core-concepts/plugins.html">Plugins</a> — Deep dive into the plugin system</li>
            <li><a href="../core-concepts/tools.html">Tools</a> — How tool execution works</li>
            <li><a href="mcp-integration.html">MCP Integration</a> — Use existing MCP servers</li>
            <li><a href="permissions.html">Permissions</a> — Control what tools can do</li>
          </ul>
        </div>
        <div class="panel-code">
          <div class="code-label">Complete plugin example</div>
          <div class="code-block">
            <pre><code class="language-python"># shared/plugins/calculator/__init__.py
from .plugin import CalculatorPlugin

PLUGIN_INFO = {
    "name": "calculator",
    "description": "Math operations",
}

def create_plugin():
    return CalculatorPlugin()

# shared/plugins/calculator/plugin.py
from shared.plugins.model_provider.types import ToolSchema

class CalculatorPlugin:
    def initialize(self, config):
        self.precision = config.get("precision", 2)

    def get_tool_schemas(self):
        return [
            ToolSchema(
                name="calculate",
                description="Evaluate math expression",
                parameters={
                    "type": "object",
                    "properties": {
                        "expression": {
                            "type": "string",
                            "description": "Math expression"
                        }
                    },
                    "required": ["expression"]
                }
            )
        ]

    def get_executors(self):
        return {"calculate": self._calculate}

    def _calculate(self, expression: str) -> str:
        try:
            # Safe eval for math only
            result = eval(expression, {"__builtins__": {}})
            return f"{expression} = {round(result, self.precision)}"
        except Exception as e:
            return f"Error: {e}"</code></pre>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script src="../assets/js/docs.js"></script>
</body>
</html>
