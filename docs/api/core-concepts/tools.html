<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tools - jaato docs</title>
  <link rel="stylesheet" href="../assets/css/style.css">
</head>
<body>
  <!-- Header -->
  <header class="header">
    <a href="../index.html" class="header-logo">
      jaato <span>docs</span>
    </a>
    <nav class="header-nav">
      <a href="../getting-started/quickstart.html">Quickstart</a>
      <a href="../api-reference/index.html">API Reference</a>
      <a href="https://github.com/apanoia/jaato" target="_blank">GitHub</a>
      <div class="header-search">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
        <input type="text" placeholder="Search docs... (press /)">
      </div>
    </nav>
  </header>

  <!-- Layout -->
  <div class="layout">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar-section">
        <div class="sidebar-title">Getting Started</div>
        <ul class="sidebar-nav">
          <li><a href="../getting-started/quickstart.html">Quickstart</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Core Concepts</div>
        <ul class="sidebar-nav">
          <li><a href="client.html">Client</a></li>
          <li><a href="plugins.html">Plugins</a></li>
          <li><a href="tools.html" class="active">Tools</a></li>
          <li><a href="providers.html">Providers</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Guides</div>
        <ul class="sidebar-nav">
          <li><a href="../guides/tool-plugins.html">Building Plugins</a></li>
          <li><a href="../guides/mcp-integration.html">MCP Integration</a></li>
          <li><a href="../guides/permissions.html">Permissions</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">API Reference</div>
        <ul class="sidebar-nav">
          <li><a href="../api-reference/index.html">Overview</a></li>
          <li><a href="../api-reference/jaato-client.html">JaatoClient</a></li>
          <li><a href="../api-reference/plugin-registry.html">PluginRegistry</a></li>
          <li><a href="../api-reference/types.html">Types</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">Provider Reference</div>
        <ul class="sidebar-nav">
          <li><a href="../api-reference/providers/index.html">Overview</a></li>
          <li><a href="../api-reference/providers/google-genai.html">Google GenAI</a></li>
        </ul>
      </div>
    </aside>

    <!-- Main content -->
    <main class="main">
      <!-- Introduction -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h1>Tools</h1>
          <p class="lead">
            Tools are capabilities that the AI model can invoke to interact
            with the outside world. Understanding how tools work is key to
            building powerful AI applications.
          </p>

          <h2 id="what-are-tools">What Are Tools?</h2>
          <p>
            Tools (also called "functions") let the model:
          </p>
          <ul>
            <li>Execute shell commands</li>
            <li>Read and write files</li>
            <li>Search the web</li>
            <li>Call external APIs</li>
            <li>Interact with databases</li>
            <li>Anything you can program</li>
          </ul>

          <p>
            Without tools, the model can only generate text. With tools, it
            can take action.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Tools in action</div>
          <div class="code-block">
            <pre><code class="language-python"># Without tools:
# User: "What files are in my directory?"
# Model: "I don't have access to your filesystem."

# With tools:
# User: "What files are in my directory?"
# Model: [calls execute_command("ls")]
# Tool: "file1.py\nfile2.py\nREADME.md"
# Model: "Your directory contains:
#         - file1.py
#         - file2.py
#         - README.md"</code></pre>
          </div>
        </div>
      </section>

      <!-- Tool Anatomy -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="anatomy">Anatomy of a Tool</h2>
          <p>
            Every tool has three components:
          </p>

          <h3>1. Schema (ToolSchema)</h3>
          <p>
            Describes the tool to the model: what it does and what parameters
            it accepts. Uses JSON Schema format.
          </p>

          <h3>2. Executor (Function)</h3>
          <p>
            The actual code that runs when the tool is called. Receives
            parameters and returns a result.
          </p>

          <h3>3. Result (ToolResult)</h3>
          <p>
            The output sent back to the model. Can be text, structured data,
            or even images.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Tool components</div>
          <div class="code-block">
            <pre><code class="language-python">from shared import ToolSchema, ToolResult

# 1. Schema - tells model what the tool does
schema = ToolSchema(
    name="get_weather",
    description="Get current weather for a city",
    parameters={
        "type": "object",
        "properties": {
            "city": {
                "type": "string",
                "description": "City name"
            },
            "units": {
                "type": "string",
                "enum": ["celsius", "fahrenheit"]
            }
        },
        "required": ["city"]
    }
)

# 2. Executor - actual implementation
def get_weather(city: str, units: str = "celsius"):
    # Call weather API...
    return f"Weather in {city}: Sunny, 22°C"

# 3. Result - what goes back to model
result = ToolResult(
    call_id="call_123",
    name="get_weather",
    result="Weather in Paris: Sunny, 22°C"
)</code></pre>
          </div>
        </div>
      </section>

      <!-- Execution Flow -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="execution-flow">Execution Flow</h2>
          <p>
            When you send a message, the client handles a multi-step process:
          </p>

          <ol>
            <li><strong>Send</strong> — Your message goes to the model</li>
            <li><strong>Decide</strong> — Model decides to use a tool</li>
            <li><strong>Call</strong> — Model returns a FunctionCall</li>
            <li><strong>Execute</strong> — ToolExecutor runs the function</li>
            <li><strong>Return</strong> — Result sent back to model</li>
            <li><strong>Continue</strong> — Model processes result</li>
            <li><strong>Repeat</strong> — Steps 2-6 may repeat</li>
            <li><strong>Complete</strong> — Model returns final text</li>
          </ol>

          <p>
            This loop continues until the model decides it has enough
            information to respond with text only.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Execution loop</div>
          <div class="code-block">
            <pre><code class="language-python"># What happens inside send_message():

# You send: "What's the weather in Paris?"

# Loop iteration 1:
#   Model response: FunctionCall(
#     name="get_weather",
#     args={"city": "Paris"}
#   )
#   Executor runs: get_weather("Paris")
#   Result: "Sunny, 22°C"
#   Send result back to model

# Loop iteration 2:
#   Model response: "The weather in Paris is
#                    sunny with a temperature
#                    of 22°C."
#   No function calls → loop ends

# Final response returned to you</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Multi-tool example</div>
          <div class="code-block">
            <pre><code class="language-python"># "Compare weather in Paris and London"

# Iteration 1: Model calls BOTH tools
#   FunctionCall(name="get_weather", args={"city": "Paris"})
#   FunctionCall(name="get_weather", args={"city": "London"})

# Both execute, results sent back

# Iteration 2: Model synthesizes
#   "Paris: Sunny, 22°C
#    London: Cloudy, 18°C
#    Paris is warmer and sunnier."</code></pre>
          </div>
        </div>
      </section>

      <!-- ToolExecutor -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="tool-executor">The ToolExecutor</h2>
          <p>
            <code>ToolExecutor</code> is responsible for running tools safely.
            It provides:
          </p>

          <table>
            <thead>
              <tr>
                <th>Feature</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Registry</strong></td>
                <td>Maps tool names to functions</td>
              </tr>
              <tr>
                <td><strong>Permissions</strong></td>
                <td>Check before executing</td>
              </tr>
              <tr>
                <td><strong>Auto-background</strong></td>
                <td>Run slow tools in background</td>
              </tr>
              <tr>
                <td><strong>Output</strong></td>
                <td>Stream output via callback</td>
              </tr>
              <tr>
                <td><strong>Accounting</strong></td>
                <td>Track execution stats</td>
              </tr>
            </tbody>
          </table>

          <p>
            Normally you don't interact with ToolExecutor directly — the
            client manages it for you.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Direct ToolExecutor usage</div>
          <div class="code-block">
            <pre><code class="language-python">from shared import ToolExecutor

# Create executor
executor = ToolExecutor()

# Register tools
executor.register("get_weather", get_weather)
executor.register("search_web", search_web)

# Execute a tool
success, result = executor.execute(
    "get_weather",
    {"city": "Paris"}
)

if success:
    print(f"Result: {result}")
else:
    print(f"Error: {result}")</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">With the client</div>
          <div class="code-block">
            <pre><code class="language-python"># Client creates executor internally
client.configure_tools(registry)

# Or configure custom tools
client.configure_custom_tools(
    tools=[weather_schema],
    executors={"get_weather": get_weather}
)

# Execution happens automatically
# when model calls tools</code></pre>
          </div>
        </div>
      </section>

      <!-- Permissions -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="permissions">Permission Control</h2>
          <p>
            Not all tool calls should execute automatically. The permission
            system lets you control what runs.
          </p>

          <h3>Permission Levels</h3>
          <table>
            <thead>
              <tr>
                <th>Level</th>
                <th>Behavior</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Auto-approve</strong></td>
                <td>Execute immediately</td>
              </tr>
              <tr>
                <td><strong>Prompt</strong></td>
                <td>Ask user for approval</td>
              </tr>
              <tr>
                <td><strong>Deny</strong></td>
                <td>Never execute</td>
              </tr>
            </tbody>
          </table>

          <h3>Auto-Approved Tools</h3>
          <p>
            Plugins can mark certain tools as safe for auto-approval via
            <code>get_auto_approved_tools()</code>. These typically include
            read-only operations.
          </p>

          <div class="callout callout-warning">
            <div class="callout-title">Security Note</div>
            Be careful with auto-approval. Tools that modify files, execute
            code, or access sensitive data should require explicit approval.
          </div>

          <p>
            For a complete guide on configuring permission policies, channels,
            and user commands, see the <a href="../guides/permissions.html">Permissions Guide</a>.
            For API reference, see the <a href="../api-reference/plugins/permission.html">Permission Plugin</a>.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Setup permissions</div>
          <div class="code-block">
            <pre><code class="language-python">from shared import PermissionPlugin

# Create permission plugin
perm = PermissionPlugin()
perm.initialize({
    "config_path": "permissions.json"
})

# Configure client with permissions
client.configure_tools(
    registry,
    permission_plugin=perm
)

# Now tool calls go through permission check</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">permissions.json</div>
          <div class="code-block">
            <pre><code class="language-python">{
  "default": "prompt",
  "rules": [
    {
      "tool": "read_file",
      "action": "allow"
    },
    {
      "tool": "execute_command",
      "action": "prompt"
    },
    {
      "tool": "delete_file",
      "action": "deny"
    }
  ]
}</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Plugin auto-approval</div>
          <div class="code-block">
            <pre><code class="language-python">class SafePlugin:
    name = "safe"

    def get_auto_approved_tools(self):
        # These don't need permission
        return [
            "get_current_time",
            "get_system_info"
        ]

    def get_tool_schemas(self):
        return [...]</code></pre>
          </div>
        </div>
      </section>

      <!-- Auto-Backgrounding -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="auto-background">Auto-Backgrounding</h2>
          <p>
            Some tools take a long time to run. Auto-backgrounding detects
            slow operations and runs them in a background thread, allowing
            the conversation to continue.
          </p>

          <h3>How It Works</h3>
          <ol>
            <li>Tool starts executing</li>
            <li>If it exceeds threshold (e.g., 5 seconds)</li>
            <li>Execution moves to background</li>
            <li>Model receives "running in background" status</li>
            <li>Model can check status or continue</li>
          </ol>

          <h3>Configuration</h3>
          <p>
            Configure via the CLI plugin or ToolExecutor:
          </p>
          <ul>
            <li><code>auto_background_enabled</code> — Enable/disable</li>
            <li><code>auto_background_threshold</code> — Seconds before backgrounding</li>
          </ul>
        </div>
        <div class="panel-code">
          <div class="code-label">Configure auto-background</div>
          <div class="code-block">
            <pre><code class="language-python"># Via CLI plugin config
registry.expose_tool("cli", config={
    "auto_background_threshold": 5.0  # seconds
})

# Via ToolExecutor directly
executor = ToolExecutor(
    auto_background_enabled=True,
    auto_background_pool_size=4
)</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Background execution flow</div>
          <div class="code-block">
            <pre><code class="language-python"># User: "Run the test suite"

# Model calls: execute_command("pytest")
# Executor starts running pytest...

# After 5 seconds, still running:
#   - Moves to background thread
#   - Returns: "Command running in background
#               (task_id: abc123)"

# Model can:
#   - Wait and check status
#   - Continue with other work
#   - Ask user to wait

# When complete:
#   - Results available via task_id
#   - Model retrieves and summarizes</code></pre>
          </div>
        </div>
      </section>

      <!-- Error Handling -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="errors">Error Handling</h2>
          <p>
            Tools can fail. The executor handles errors gracefully and reports
            them back to the model.
          </p>

          <h3>Error Types</h3>
          <table>
            <thead>
              <tr>
                <th>Type</th>
                <th>Cause</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Not Found</strong></td>
                <td>Tool doesn't exist</td>
              </tr>
              <tr>
                <td><strong>Permission</strong></td>
                <td>Execution denied</td>
              </tr>
              <tr>
                <td><strong>Execution</strong></td>
                <td>Tool threw an exception</td>
              </tr>
              <tr>
                <td><strong>Timeout</strong></td>
                <td>Execution took too long</td>
              </tr>
            </tbody>
          </table>

          <p>
            Errors are wrapped in <code>ToolResult</code> with
            <code>is_error=True</code>. The model sees the error message
            and can decide how to proceed.
          </p>
        </div>
        <div class="panel-code">
          <div class="code-label">Error handling in tools</div>
          <div class="code-block">
            <pre><code class="language-python">def read_file(path: str) -> str:
    try:
        with open(path) as f:
            return f.read()
    except FileNotFoundError:
        raise ValueError(f"File not found: {path}")
    except PermissionError:
        raise ValueError(f"Permission denied: {path}")

# Executor catches exceptions and returns:
# ToolResult(
#     call_id="...",
#     name="read_file",
#     result="Error: File not found: /foo/bar",
#     is_error=True
# )</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Model sees errors</div>
          <div class="code-block">
            <pre><code class="language-python"># User: "Read /nonexistent/file.txt"

# Model calls: read_file("/nonexistent/file.txt")
# Tool returns error

# Model receives:
# ToolResult(is_error=True,
#            result="File not found")

# Model responds:
# "I couldn't read that file because it
#  doesn't exist. Would you like me to
#  create it, or did you mean a different
#  path?"</code></pre>
          </div>
        </div>
      </section>

      <!-- Output Streaming -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="output">Output Streaming</h2>
          <p>
            Tools can stream output in real-time via the output callback.
            This is useful for long-running operations or verbose tools.
          </p>

          <p>
            The callback set on the executor (via client) receives:
          </p>
          <ul>
            <li><code>source</code> — Plugin/tool name</li>
            <li><code>text</code> — Output text</li>
            <li><code>mode</code> — "write" or "append"</li>
          </ul>
        </div>
        <div class="panel-code">
          <div class="code-label">Streaming output</div>
          <div class="code-block">
            <pre><code class="language-python"># CLI plugin streams command output:

# User: "Run pytest -v"
# Model calls: execute_command("pytest -v")

# Output callback receives:
# ("cli", "===== test session starts =====", "write")
# ("cli", "\ncollected 10 items", "append")
# ("cli", "\ntest_foo.py::test_one PASSED", "append")
# ("cli", "\ntest_foo.py::test_two PASSED", "append")
# ...

# User sees output in real-time!</code></pre>
          </div>

          <div class="code-label" style="margin-top: 24px;">Custom tool with streaming</div>
          <div class="code-block">
            <pre><code class="language-python">class StreamingPlugin:
    name = "streaming"

    def __init__(self):
        self._output_callback = None

    def set_output_callback(self, callback):
        self._output_callback = callback

    def _stream_output(self, text, mode="append"):
        if self._output_callback:
            self._output_callback(self.name, text, mode)

    def long_operation(self):
        self._stream_output("Starting...", "write")
        for i in range(10):
            time.sleep(0.5)
            self._stream_output(f"\nStep {i+1}/10")
        return "Complete!"</code></pre>
          </div>
        </div>
      </section>

      <!-- Next Steps -->
      <section class="two-panel">
        <div class="panel-explanation">
          <h2 id="next-steps">Next Steps</h2>
          <ul>
            <li><a href="providers.html">Providers</a> — Multi-provider abstraction</li>
            <li><a href="../guides/tool-plugins.html">Building Plugins</a> — Create your own tools</li>
            <li><a href="../guides/permissions.html">Permissions</a> — Configure security</li>
            <li><a href="../api-reference/tool-executor.html">ToolExecutor API</a> — Full reference</li>
          </ul>
        </div>
        <div class="panel-code">
          <div class="code-label">Tool types summary</div>
          <div class="code-block">
            <pre><code class="language-python"># Types you'll work with:

from shared import (
    # Declare tools
    ToolSchema,

    # Model requests tool use
    FunctionCall,

    # Tool returns result
    ToolResult,

    # Attach files/images
    Attachment,
)

# Flow:
# ToolSchema → Model → FunctionCall
#           → Executor → ToolResult
#           → Model → Response</code></pre>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script src="https://unpkg.com/lunr@2.3.9/lunr.min.js"></script>


  <script src="../assets/js/docs.js"></script>
</body>
</html>
